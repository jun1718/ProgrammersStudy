21.10.23_9회차
===============================================================================
*그리디_탐욕법(구명보트), 깊이우선탬색(DFS)
===============================================================================









################################################################################################################
예제20)그리디_탐욕법

1)구명보트

무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있습니다.

예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다.

구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다.

사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요.

제한사항
무인도에 갇힌 사람은 1명 이상 50,000명 이하입니다.
각 사람의 몸무게는 40kg 이상 240kg 이하입니다.
구명보트의 무게 제한은 40kg 이상 240kg 이하입니다.
구명보트의 무게 제한은 항상 사람들의 몸무게 중 최댓값보다 크게 주어지므로 사람들을 구출할 수 없는 경우는 없습니다.
입출력 예
people	limit	return
[70, 50, 80, 50]	100	3
[70, 80, 50]	100	3

히든케이스: 40,50,150,160 limit 200 > 2
	-처음 작은 몸무게의 사람들기준으로 비교해서 태우면 안된다는 반증
	100,500,500,900,950 limit 1000 > 3
	-가장 처음의 값과 마지막부터 감소한 인덱스들의 값들을 더한것들이 limit보다 클시
		그사람들부터 태워가야한다는 예시

################################################################################################################


답:





import java.util.*;

class Solution {
    public int solution(int[] people, int limit) {
        int answer = 0;
        
        Arrays.sort(people);
        int len = people.length-1;
        
        for(int i=0;i<=len;i++) {
        	while(len>i&&people[i]+people[len--] > limit) {
        		answer++;
        	}
        	answer++;
        }
     
        return answer;
    }
}







1+1+1+1+1
1+1+1+1-1
1+1+1-1+1
1+1+1-1-1
1+1-1+1+1
1+1-1+1-1
1+1-1-1+1
1+1-1-1-1










################################################################################################################
예제21)깊이 우선탐색(DFS)

1)아래 링크에 들어가서 나온 그래프대로 이루어지도록 dfs 를 구현하라

https://codingnojam.tistory.com/44

################################################################################################################


답:


package study.blog.codingnojam;
public class Study_DFS_Recursion {
// 방문처리에 사용 할 배열선언
static boolean[] vistied = new boolean[9];
// 그림예시 그래프의 연결상태를 2차원 배열로 표현
// 인덱스가 각각의 노드번호가 될 수 있게 0번인덱스는 아무것도 없는 상태라고 생각하시면됩니다.
static int[][] graph = {{}, {2,3,8}, {1,6,8}, {1,5}, {5,7}, {3,4,7}, {2}, {4,5}, {1,2}};
public static void main(String[] args) {
dfs(1);
}
static void dfs(int nodeIndex) {
// 방문 처리
vistied[nodeIndex] = true;
// 방문 노드 출력
System.out.print(nodeIndex + " -> ");
// 방문한 노드에 인접한 노드 찾기
for (int node : graph[nodeIndex]) {
// 인접한 노드가 방문한 적이 없다면 DFS 수행
if(!vistied[node]) {
dfs(node);
}
}
}
}

출처: https://codingnojam.tistory.com/44 [코딩은 알면 know jam! 모르면 no jam!]














################################################################################################################
예제22)깊이 우선탐색(DFS)

1)타겟넘버
n개의 음이 아닌 정수가 있습니다. 이 수를 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3
사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.

제한사항
주어지는 숫자의 개수는 2개 이상 20개 이하입니다.
각 숫자는 1 이상 50 이하인 자연수입니다.
타겟 넘버는 1 이상 1000 이하인 자연수입니다.
입출력 예
numbers	target	return
[1, 1, 1, 1, 1]	3	5
입출력 예 설명
문제에 나온 예와 같습니다.
################################################################################################################


답:




class Solution {
	int answer = 0;
	
	public void dfs(int[] numbers, int depth, int target, int result) {
		if(depth == numbers.length) {
			if(target==result) {
				answer++;
			}
			return;
		}
		
		int add = result + numbers[depth];
		int sub = result - numbers[depth];
		
		dfs(numbers, depth+1, target, add);
		dfs(numbers, depth+1, target, sub);
	}
	
    public int solution(int[] numbers, int target) {
        
        
        dfs(numbers, 0, target, 0);
        
        return answer;
    }
}